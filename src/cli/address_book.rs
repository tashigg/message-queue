use std::fs::OpenOptions;
use std::net::{IpAddr, SocketAddr};
use std::path::{Path, PathBuf};
use std::{fs, io};

use color_eyre::eyre;
use color_eyre::eyre::{eyre, WrapErr};
use serde::Serialize;
use tashi_collections::HashSet;
use tashi_consensus_engine::SecretKey;

use crate::cli::LogFormat;
use crate::config::addresses::Address;

#[derive(clap::Args, Clone, Debug)]
pub struct AddressBookArgs {
    #[command(subcommand)]
    command: AddressBookCommand,
}

#[derive(clap::Args, Clone, Debug)]
struct Common {
    /// The path to write the address book and key PEM files to.
    ///
    /// Will be created if it doesn't already exist.
    ///
    /// An error will be returned if the directory already contains an `address-book.toml` or
    /// any `key_*.pem` files.
    ///
    /// Pass `-f`/`--force` to overwrite any existing files.
    #[clap(long, short = 'O', default_value = "foxmq.d/")]
    output_dir: PathBuf,

    /// If any file generated by the command already exists, overwrite it instead of erroring.
    #[clap(long, short = 'f')]
    force: bool,

    #[clap(short, long, default_value = "full")]
    log: LogFormat,
}

#[derive(clap::Subcommand, Clone, Debug)]
#[clap(rename_all = "kebab-case")]
enum AddressBookCommand {
    /// Generate the address book from a list of predetermined socket addresses.
    FromList {
        // Needs to be part of the subcommand arguments to parse after the subcommand
        #[clap(flatten)]
        common: Common,

        /// The list of socket addresses (IP:port) to include in the address book.
        ///
        /// An error will be returned if the same address is listed more than once.
        #[clap(required = true)]
        socket_addresses: Vec<SocketAddr>,
    },
    /// Generate the address book from a base IP address and a range of ports.
    ///
    /// The total number of addresses generated will be `PORT_END - PORT_START + 1`
    /// (because the range is inclusive).
    FromRange {
        #[clap(flatten)]
        common: Common,

        /// The base IP address which will be affixed with ports in the given range.
        base_address: IpAddr,
        /// The start of the port range (inclusive).
        port_start: u16,
        /// The end of the port range (inclusive).
        port_end: u16,
    },
}

impl AddressBookArgs {
    pub fn log_format(&self) -> LogFormat {
        match &self.command {
            AddressBookCommand::FromList { common, .. } => common.log,
            AddressBookCommand::FromRange { common, .. } => common.log,
        }
    }
}

pub fn main(args: AddressBookArgs) -> crate::Result<()> {
    match args.command {
        AddressBookCommand::FromList {
            socket_addresses,
            common,
        } => {
            eyre::ensure!(!socket_addresses.is_empty(), "address list is empty");
            generate_address_book(
                socket_addresses.into_iter(),
                &common.output_dir,
                common.force,
            )
        }
        AddressBookCommand::FromRange {
            base_address,
            port_start,
            port_end,
            common,
        } => {
            let port_range = port_start..=port_end;
            eyre::ensure!(
                !port_range.is_empty(),
                "port range is empty: [{port_start}, {port_end}]"
            );

            generate_address_book(
                port_range.map(|port| SocketAddr::new(base_address, port)),
                &common.output_dir,
                common.force,
            )
        }
    }
}

fn generate_address_book(
    addresses: impl Iterator<Item = SocketAddr>,
    output_dir: &Path,
    force: bool,
) -> crate::Result<()> {
    use std::fmt::Write;

    fs::create_dir_all(output_dir)
        .wrap_err_with(|| format!("failed to create {}", output_dir.display()))?;

    let mut address_book = String::new();

    let mut address_set = HashSet::with_hasher(Default::default());

    let address_book_path = output_dir.join("address-book.toml");

    // Instead of the previous behavior of erroring if the directory was not empty,
    // we error if any file we're trying to write already exists and `--force` was not passed.
    //
    // This gives the user more flexibility if they call another command first, like `user add`.
    //
    // This could leave some partially written files if `address_book.toml` isn't the first one we hit,
    // but I don't think that's a big deal. The user can always clean them up manually.
    eyre::ensure!(
        force || !address_book_path.exists(),
        "{} already exists; pass `-f`/`--force` to overwrite",
        address_book_path.display()
    );

    for (i, address) in addresses.enumerate() {
        eyre::ensure!(address_set.insert(address), "Duplicate address: {address}");

        let key = SecretKey::generate();
        let pubkey = key.public_key();

        let pem = key.to_pem();

        let pem_filename = format!("key_{i}.pem");
        let pem_path = output_dir.join(&pem_filename);

        write_new_file(&pem_path, pem, force)?;

        // Mark each entry with a comment referencing its key file.
        writeln!(address_book, "# {pem_filename}").expect("writing to a String cannot fail");

        // Serialize entries one at a time, so we can add a comment above each one.
        #[derive(serde::Serialize)]
        struct AddressBookEntry {
            addresses: [Address; 1],
        }

        AddressBookEntry {
            addresses: [Address {
                key: pubkey,
                addr: address,
            }],
        }
        .serialize(toml::Serializer::new(&mut address_book))
        .expect("failed to serialize AddressBookEntry");

        // Add a blank line between entries for readability.
        address_book.push('\n');
    }

    // This avoids a TOCTOU bug by checking again if `force` is `false`.
    write_new_file(address_book_path, &address_book, force)?;

    Ok(())
}

/// Write `contents` to a new file at `path`, erroring if it exists and `force` is not `true`.
///
/// If `force` is `true`, the existing file is truncated instead.
fn write_new_file(
    path: impl AsRef<Path>,
    contents: impl AsRef<[u8]>,
    force: bool,
) -> crate::Result<()> {
    use std::io::Write;

    let path = path.as_ref();

    let mut file = OpenOptions::new()
        .write(true)
        // `truncate()` and `create()` are ignored on `create_new(true)`
        .create_new(!force)
        .create(true)
        .truncate(force)
        .open(path)
        .map_err(|e| {
            if e.kind() == io::ErrorKind::AlreadyExists {
                eyre!(
                    "could not create {} as it already exists; pass `-f`/`--force` to overwrite",
                    path.display()
                )
            } else {
                eyre!(e).wrap_err(format!("error opening {} for writing", path.display()))
            }
        })?;

    file.write_all(contents.as_ref())
        .wrap_err_with(|| format!("error writing to {}", path.display()))?;

    file.sync_all()?;

    Ok(())
}
